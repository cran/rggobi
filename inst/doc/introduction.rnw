\documentclass[a4paper]{report}
\usepackage{Rnews}
\usepackage[round]{natbib}
\bibliographystyle{abbrvnat}

%\documentclass[oneside,letterpaper]{scrartcl}
\usepackage[utf8]{inputenc}
%\usepackage[pdftex]{graphicx}
\usepackage{hyperref}
%\usepackage{fullpage}
\usepackage{alltt}

\begin{document}
\begin{article}

\title{An introduction to rggobi}
%\VignetteIndexEntry{An introduction to rggobi}
\author{Hadley Wickham, Michael Lawrence, \\
Duncan Temple Lang, Deborah F Swayne}

\maketitle

\section{Introduction}

The rggobi package provides a command-line interface to GGobi, an interactive and dynamic graphics package.  Rggobi complements GGobi's graphical user interface, providing a way to fluidly transition between analysis and exploration, as well as automating common tasks.  It builds on the first version of rggobi to provide a more robust and user friendly interface.  In this article, we will show you how you can starting using rggobi now, and learn some ways to gain insight into your data using a combination of analysis and visualisation. 

% GGobi is a tool for highly interactive and dynamic graphics.  It allows you to explore your data visually with a special set of tools including linked brushing and the grand tour.  Linked brushing is a key component of interactive graphics, and is necessary as soon as you have more than one plot of the same data.  Linked brushing lets you identify which points in different plots correspond to the same underlying  observation.  It can be used to investigate high-dimensional relationships.  The grand tour is another way of looking at high-dimensional data.  If you imagine your data as points in a $p$ dimensional space, the grand tour randomly and smoothly rotates your data and projects it down on a 2D plane.  With some training, the grand tour allows you to see high-dimensional patterns that you can't otherwise.  

We do assume some familiarity with GGobi.  If you're not familiar, but would like to learn more have a look at the GGobi web site, \url{http://www.ggobi.org}, especially the demos of GGobi's capabilities found at \url{http://www.ggobi.org/docs}.  You will also need to have a copy of GGobi installed before continuing: download a version for your platform from \url{http://www.ggobi.org/downloads}.  You can then install rggobi and it's dependencies using {\tt install.packages("rggobi", dep=T)}.

This article introduces the three main components of rggobi, with examples of how you might use them in day-to-day tasks:

\begin{itemize}
	\item Getting data into and out of GGobi.
	\item Modifying observation-level attributes, or automatic brushing.
	\item Basic plot control.
\end{itemize}

\noindent We will also disucess some advanced techniques such as creating animations with GGobi, edges and longitudinal data. Finally, a case study shows how to use rggobi to create a visualisation for a statistical algorithm: manova.

\section{Data}\label{sec:data}

Getting data from R into GGobi is easy: \verb|g <- ggobi(mtcars)|.  This creates a {\tt GGobi} object called {\tt g}.  Getting data out isn't much harder, just index that {\tt GGobi} object by position, {\tt g[[1]]}, or by name, {\tt g[["mtcars"]]}, {\tt g\$mtcars}.  These return {\tt GGobiData} objects which are linked to the data in GGobi.  These act just like regular data frames, except that changes are synchronised with GGobi.  You can get a static copy of the data using {\tt as.data.frame}.

Once you have your data in GGobi, it's easy to do something that was hard before: finding multivariate outliers.  It is customary to look at uni- or bivariate plots to look for uni- or bivariate outliers, but higher dimensional outliers may go unnoticed.  Looking for these outliers is easy to do with the tour.  Open your data with GGobi and then change to the tour view and select all the variables.  Watch the tour and look for points that are far away or move differently from the others---these are outliers.

Adding more data sets to an open GGobi is also easy: {\tt g\$mtcars2 <- mtcars} will add another data set named ``mtcars2''.  You can load any file type that GGobi recognises by passing the path to that file.  In conjunction with {\tt ggobi\_find\_file}, which locates files in the GGobi installation directory, this makes it easy to load GGobi sample data.  This example loads the olives data set included with GGobi.

\begin{alltt}
ggobi(ggobi_find_file("data", "olives.csv"))
\end{alltt}

\section{Modifying observation-level \\
attributes, or automatic brushing}\label{sec:meta_data}

Brushing lets you interactively change the colour, glyph type and size of points.  Brushing is linked, which means that these changes will propagate to every plot in which the brushed observations are displayed.  Brushing includes shadowing, where points sit in the background and have less visual impact, and exclusion, where points are completed excluded from the plot.  You can brush points ``automatically'', from R, using the following functions to:

\begin{itemize}
	\item change glyph colour with {\tt glyph\_colour}
	\item change glyph size with  {\tt glyph\_size}
	\item change glyph type with {\tt glyph\_type}
	\item shadow and unshadow points with {\tt shadowed}
	\item exclude and include points with {\tt excluded}
\end{itemize}

Each of these get or set the current values for the specified {\tt GGobiData}.  The getters are useful for retrieving information that you have created while brushing in GGobi, and the setters can be used to change the appearance of points based on model information, or to create animations.  They can also be used to store, and then later recreate, the results of a complicated sequence of brushing steps.

This example demonstrates the use of the {\tt glyph\_colour} to show the results of clustering the infamous Iris data using hierachical clustering.  Using GGobi allows us to investigate the clustering in the original dimensions of the data.  The graphic shows a single projection from the grand tour.  

\begin{verbatim}
g <- ggobi(iris)
clustering <- hclust(dist(iris[,1:4]), 
  method="average")
glyph_colour(g[1]) <- cuttree(clustering, 3)  
\end{verbatim}

\begin{center}
  \includegraphics[width=2in]{clustering.png}  
\end{center}

Another function, {\tt selected}, returns a logical vector indicating if each point is currently under the brush.  This could be used to further explore interesting or unusual points.

\section{Displays}\label{sec:display}

A {\tt GGobiDisplay} represents a window containing one or more related plots.  With rggobi you can create new displays, change the interaction or projection mode of an existing plot, or change which variables are displayed. 

To retrieve a list of displays, use the {\tt displays} function.  To create a new display use the {\tt display} method on a {\tt GGobiData} object.  You'll need to specify the type of plot you want (the default is a XY Plot) and which variables to include.  For example:

\begin{verbatim}
g <- ggobi(mtcars)
display(g[1], vars=list(X=4, Y=5))
display(g[1], vars=list(X="drat", Y="hp"))
display(g[1], "Parallel Coordinates Display")
display(g[1], "2D Tour")
\end{verbatim}

The following types of displays are available in GGobi:

\hspace{1em}

\begin{tabular}{ll}
Name & Variables\\
\hline                      
1D Plot                      & $1$ X\\
XY Plot                      & $1$ X, $1$ Y\\
1D Tour                      & $n$ X \\
Rotation                     & $1$ X, $1$ Y, $1$ Z\\
2D Tour                      & $n$ X\\
2x1D Tour                    & $n$ X, $n$ Y\\
Scatterplot Matrix           & $n$ X\\
Parallel Coordinates Display & $n$ X\\
Time Series                  & $1$ X, $n$ Y\\
Barchart                     & $1$ X\\
\end{tabular}

\hspace{1em}

After creating a plot you can get and set the displayed variables using the {\tt variable} and {\tt variable<-} methods.  Because of the range of plot types in GGobi, variables should be specified as a list containing {\tt X}, {\tt Y} and {\tt Z} character vectors listing the variable or variables to be used for each component.

\begin{verbatim}
g <- ggobi(mtcars)
d <- display(g[1], 
  "Parallel Coordinates Display")
variables(d)
variables(d) <- list(X=8:6)
variables(d) <- list(X=8:1)
variables(d)
\end{verbatim}

Another useful function is \verb|ggobi_display_save_picture|, which saves the contents of a GGobi display to a file on disk.  This is what we used to create the images in this document.  This creates an exact (raster) copy of the GGobi display.  If you want to create publication quality graphics from GGobi, have a look at the {\tt DescribeDisplay} plugin and package at  \url{http://www.ggobi.org/describe-display}.  These create R versions of your GGobi plots.

\section{Animation}\label{sec:animation} % (fold)

Any changes that you make to the {\tt GGobiData} objects are updated in GGobi immediately, so you can easily create animations.  This example scrolls through a long time series:

\begin{verbatim}
df <- data.frame(
  x=1:2000, 
  y=sin(1:2000 * pi/20) + runif(2000, max=0.5)
)
g <- ggobi_longitudinal(df[1:100, ])

df_g <- g[1]
for(i in 1:1901) {
  df_g[, 2] <- df[i:(i + 99), 2]
}
\end{verbatim}

\begin{center}
  \includegraphics[width=1.2in]{time-series-1.png}
  \includegraphics[width=1.2in]{time-series-2.png}

  \includegraphics[width=1.2in]{time-series-3.png}
  \includegraphics[width=1.2in]{time-series-4.png}
\end{center}

% section animation (end)

\section{Edge data}\label{sec:edge_data}

Edge data sets are a special type of dataset.  Instead of representing points, they represent connections, or edges, between observations.  These can be used to represent many different types of data, for example, distances between observations, social relationships, biological pathways, and so on.

In this example we are going to visualise some data from the social network analysis package: marital and business relationships between Florentine families in the 15th century.

\begin{verbatim}
library(graph)
library(SNAData)

data(business, marital, florentineAttrs)

g <- ggobi(florentineAttrs)
edges(g) <- business
edges(g) <- marital
\end{verbatim}

This example creates two edge datasets.  We can use the edges menu in GGobi to change between the different edge sets.

\begin{center}
  \includegraphics[width=1.5in]{florentine-business.png}
  \includegraphics[width=1.5in]{florentine-marital.png}  
\end{center}

How is this stored in GGobi?  An edge dataset records the names of the source and destination observations for each edge.  You can convert a regular dataset into a edge dataset with the {\tt edges} function.  This takes a matrix with two columns, source and destination names, with a row for each edge observation.  Typically, you will need to add a new data frame with number of rows equal to the number of edges you want to add

\subsection{Longitudinal data}\label{sub:longitudinal_data} % (fold)

A special case of data with edges is time series or longitudinal data, in which observations adjacent in time are connected with a line.  Rggobi provides a convenient function for creating edge sets for longitudinal data, {\tt ggobi\_longitudinal}.  This will link together observations in sequential time order and is good for looking at time series or longitudinal data.

This example uses the {\tt stormtracks} data included in rggobi.  The first argument gives the dataset to use, the second the variable that specifies the time component, and the third variable separates different observations.

\begin{alltt}
ggobi_longitudinal(stormtracks, seasday, id)
\end{alltt}

For regular time series data (already in order, with no grouping variables), just use {\tt ggobi\_longitudinal} with no other arguments.

\begin{center}
  \includegraphics[width=2in]{stormtracks.png}  
\end{center}
% subsection longitudinal_data (end)


\section{Case study}\label{sec:section_name}

Graphical methods are great for determining if two (or more) clusters of data are non-overlapping, but they are less useful for examining differences between means.  This case study explores using rggobi to add model information to data; here will add confidence ellipsoids around the means so we can perform a graphical manova.

The first (and most complicated) step is to generate the confidence ellipsoids.  The {\tt ellipse} function does this.  First we generate random points on the surface of sphere, by drawing $npoints$ from a random normal distribution and then standardising each dimension.  This sphere is then skewed to match the desired variance-covariance matrix, and its size adjusted to give the appropriate $cl$-level confidence ellipsoid.  Finally, the ellipsoid is translated to match the column locations.

\begin{verbatim}
ellipse <- function(data, npoints=1000, 
  cl=0.95, mean=colMeans(data), cov=var(data), 
  n=nrow(data)
) {
  norm.vec  <-  function(x) x / sqrt(sum(x^2))

  p <- length(mean)
  ev <- eigen(cov)

  sphere <- matrix(rnorm(npoints*p), ncol=p)
  cntr <- t(apply(sphere, 1, norm.vec))

  cntr <- cntr %*% 
    diag(sqrt(ev$values)) 
    %*% t(ev$vectors)
  cntr <- cntr * sqrt(p * (n-1) * 
    qf(cl, p, n-p) / (n * (n-p)))
  if (!missing(data)) 
    colnames(cntr) <- colnames(data)

  cntr + rep(mean, each=npoints) 
}
\end{verbatim}

We can look at the output with ggobi:

\begin{verbatim}
ggobi(ellipse(mean=c(0,0), cov=diag(2), n=100))

cv <- matrix(c(1,0.15,0.25,1), ncol=2)
ggobi(ellipse(
  mean=c(1,2), cov=cv, n=100
))

ggobi(ellipse(
  mean=c(0,0,1,2), cov=diag(4), n=100
))

ggobi(ellipse(
  matrix(rnorm(20), ncol=2
))
\end{verbatim}

\begin{center}
  \includegraphics[width=1.5in]{ellipse-2d.png}
  \includegraphics[width=1.5in]{ellipse-4d.png}
\end{center}

In the next step, we will need to take the original data and supplement it with the generated ellipsoid:

\begin{verbatim}
manovaci <- function(data, cl=0.95) {
  dm <- data.matrix(data)
  ellipse <- as.data.frame(
    ellipse(dm, n=1000, cl=cl)
  )

  both <- rbind(data, ellipse)
  both$SIM <- factor(
    rep(c(FALSE, TRUE), c(nrow(data), 1000))
  )

  both
}
ggobi(manovaci(matrix(rnorm(30), ncol=3)))
\end{verbatim}

Finally, we create a method that will break a dataset into pieces based on a categorical variable and compute the mean confidence ellipsoid for each one.  We will then use the automatic brushing functions to make the ellipsoid distinct, and colour each of the groups a different colour.  Here we use 68\% confidence ellipsoids so that non-overlapping ellipsoids imply a significant different in the means.

\begin{verbatim}
ggobi_manova <- function(data, catvar, cl=0.68) {
  each <- split(data, catvar)
  cis <- lapply(each, manovaci, cl=cl)

  df <- as.data.frame(do.call(rbind, cis))
  df$var <- factor(rep(
    names(cis), sapply(cis, nrow)
  ))

  g <- ggobi(df)
  glyph_type(g[1]) <- c(6,1)[df$SIM]
  glyph_colour(g[1]) <- df$var
  invisible(g)
}  
\end{verbatim}


These images show a graphical manova.  You can see that in some projections the means overlap, but in others they do not.

\begin{center}
  \includegraphics[width=1.5in]{manova1.png}
  \includegraphics[width=1.5in]{manova2.png}
\end{center}

\section{Conclusion}\label{sec:conclusion}

GGobi is a powerful tool for data exploration, and the integration with R that rggobi allows a seamless workflow between analysis and exploration.  Much of the potential of rggobi has yet to be explored, but some ideas are demonstrated in the {\tt classifly} package, \url{http://had.co.nz/classifly} which visualises high-dimensional classification boundaries.   We are also keen to hear about your work---if you develop a package using rggobi please let us know so we can highlight your work on the GGobi homepage.

We are currently working on the infrastructure behind GGobi and rggobi to allow greater control from within R.  The next version of rggobi will offer a direct low-level binding to every function in GGobi, giving total control.  We are also working on consistently generating events in Ggobi so that you will be able respond to events that you are interesting in from your R code.  Together with the RGtk2 package, this should allow the development of custom interactive graphics for specific tasks, written purely with high-level R code.

\end{article}
\end{document}